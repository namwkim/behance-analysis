---
title: "Behance Exploratory Analysis"
author: Nam Wook Kim
date: Nov 18, 2016
output: 
  html_notebook
---

**Install dependent libraries**

```{r, message=FALSE, warning=FALSE}
# require packages
if (!require(plyr)) {install.packages("plyr"); library(plyr)}
if (!require(psych)) {install.packages("psych"); library(psych)}
if (!require(graphics)) {install.packages("graphics"); library(graphics)}
if (!require(maps)) {install.packages("maps"); library(maps)}
if (!require(ggplot2)) {install.packages("ggplot2"); library(ggplot2)}
if (!require(plotly)) {install.packages("plotly"); library(plotly)}
if (!require(countrycode)) {install.packages("countrycode"); library(countrycode)}
if (!require(MASS)) {install.packages("MASS"); library(MASS)}
if (!require(pscl)) {install.packages("pscl"); library(pscl)}
if (!require(QuantPsyc)) {install.packages("QuantPsyc"); library(QuantPsyc)}
if (!require(reshape2)) {install.packages("reshape2"); library(reshape2)}
if (!require(corrplot)) {install.packages("corrplot"); library(corrplot)}
if (!require(jsonlite)) {install.packages("jsonlite"); library(jsonlite)}
if (!require(hash)) {install.packages("hash"); library(hash)}
if (!require(relaimpo)) {install.packages("relaimpo"); library(relaimpo)}
if (!require(lmtest)) {install.packages("lmtest"); library(lmtest)}
if (!require(MASS)) {install.packages("MASS"); library(MASS)}
if (!require(proxy)) {install.packages("proxy"); library(proxy)}
#
```
**Load data**
```{r}
users = read.csv('../data/sampled-graph/users-100.csv')
designs = read.csv('../data/sampled-graph/designs-100.csv')
links = read.csv('../data/sampled-graph/links-100.csv')
```
**Plot the distribution of signed-up dates**

```{r}
dates<-as.Date(as.POSIXct(users$created_on, origin="1970-01-01")) 
dates<-data.frame(table(dates)) 
dates$dates <- as.Date(dates$dates)
p <- ggplot(dates, aes(x=dates, y=Freq, group=1)) + 
  geom_point(color='#CC79A7', alpha=0.9) +  geom_smooth(color='#56B4E9') +
  ggtitle('The distribution of signed-up dates') + 
  labs(x='Dates', y='Frequency')

p
```

**The number of users by gender**

```{r}
allgender<-subset(users, gender=="male"|gender=="female")
male<-subset(users, gender=="male" )
female<-subset(users, gender=="female" )
unknown<-subset(users, gender=="unknown" )
nrow(allgender)
nrow(male)
nrow(female)
nrow(unknown)
```

**The number of countries by by country**: After gender inferences, rankings change a bit. For instance, asian names' genders were not accurately inferred (rank 4 > 19). But, most rankings remain similar after the gender prediction.
```{r}
topCountries<-function(d){
  c<-count(d, "country")
  c<-c[order(-c$freq),]
  c
}
totalP<-topCountries(users)
allGenderP<-topCountries(allgender)
maleP<-topCountries(male)
femaleP<-topCountries(female)
c<-cbind(1:20, totalP[1:20, ], allGenderP[1:20, ])
colnames(c) <- c('rank', 'country (all)', 'frequency (all)', 'country (male+female)', 'frequency (male+female)')
c
c<-cbind(1:20, maleP[1:20, ], femaleP[1:20, ])  # top 5 remain the same across gender
colnames(c) <- c('rank', 'country (male)', 'frequency (male)', 'country (female)', 'frequency (female)')
c
```

**World choropleth map of population**
```{r Code Chunk, fig.width = 10, fig.height = 10}
# convert country names to country codes
totalP$country_code <-countrycode(totalP$country, "country.name", "iso3c")
totalP<-na.omit(totalP) # remove missing data
# draw map
l <- list(color = toRGB("grey"), width = 0.5)
g <- list(
  showframe = FALSE,
  showcoastlines = FALSE,
  projection = list(type = 'Mercator')
)
plot_geo(totalP, width=700, height=450) %>%
  add_trace(
    z = ~freq, text = ~country, locations = ~country_code,
    color = ~freq, colors = 'Reds'
  ) %>%
  layout(title = 'Population by Countries', geo = g)
```

 **u.s choropleth map (since it has the most population)**
```{r, eval=FALSE}
# usdata<-users[users$country=="United States",]
# statecount<-count(usdata, 'state')
# statecount$state_code<-state.abb[match(statecount$state, state.name)]
# statecount<-na.omit(statecount)
# g <- list(
#   scope = 'usa',
#   projection = list(type = 'albers usa'),
#   showlakes = TRUE,
#   lakecolor = toRGB('white')
# )
# plot_geo(statecount, width=700, height=450, locationmode = 'USA-states') %>%
#   add_trace(
#     z = ~freq, text = ~state, locations = ~state_code,
#     color = ~freq, colors = 'Reds'
#   ) %>%
#   layout(title = 'Population by Users', geo = g)
  
```
**Summary statistics : gender and occupation**
```{r}
summary(allgender$gender)
# summary(allgender$occupation)
```
**Summary statistics : other  numeric variables**
```{r}
drops<-c("following", "followers","comments",
         "project_counts", "project_views", "project_appreciations", "project_comments",
         "collection_counts", "collection_item_counts", "collection_followers")
measures<-users[, (names(users) %in% c(drops))] # only numeric variables
summary(measures)
```
** The percentage of zero values per each numeric variable.**
```{r}
colSums(measures==0)/nrow(measures)*100

```
**Correlatin between predictors**
The follwoing are highly correlated groups:
1) group1: project_appreciations, project_comments, project_views, followers
- follower counts seems related to project appreciations
2) group4: project_counts
- it's interesting that project counts are not necessarily correlated with other project-related measures
3) group5: following
- this is also not necessarily correlated with "follwers"
4) group6: collection_followers, collection_item_counts
5) group7: collection counts
- As the same as projects, collection counts are not correlated with collection followers. However, collection item counts are correlted with the follower counts.
```{r}
measures<-allgender[, (names(allgender) %in% drops)] # only numeric variables
corrplot(cor(measures), order="FPC")
```
### Specialization
RQ. What topic is the most popular one and by which gender?
```{r}

# API call to retrieve pre-defined popular creative fields from behance
cfs<-fromJSON("https://api.behance.net/v2/fields?client_id=ancBdHFrtqhJM18AUzqev2wvgjM0PGnj")
# clean the fields
cfs$fields$abbr_name<-sapply( cfs$fields[2], function(x){
  tolower(gsub(" ", "_", x))
});
systemFields<-as.vector(cfs$fields$abbr_name)

# calculate topic rankings of users' fields
calcTopicRanks<-function(fields){
  userFields<-hash()
  a<-sapply(fields, function(f){
    if (nchar(as.character(f))!=0){
      # process users' fields concatenated by '|'
      splited<-strsplit(as.character(f), "|", fixed = TRUE)
      splited<-unlist(splited)
      for (i in 1:length(splited)){
        field<-tolower(gsub(" ", "_", splited[i]))
        if (has.key(field, userFields)==FALSE){
          userFields[[field]]<-0
        }
        userFields[[field]]<-userFields[[field]]+1
      }
    }
  })
  # sort by the number of users for topics
  userFields<-sort(values(userFields), decreasing=TRUE)
  # return user fields
  userFields
}
# visualize the rankings (up to # rankings)
visualizeRanks<-function(fields, upto){
  ranks<-data.frame(fields=names(fields[1:upto]), counts=fields[1:upto])
  # reorder factors to match colors and bars
  ranks$fill<-factor(ranks$fields, levels = ranks$fields[order(ranks$counts, decreasing=TRUE)])
  ranks$x<-as.character(1:length(ranks$fields))
  ranks$x<-factor(ranks$x, levels = ranks$x[order(ranks$counts, decreasing=TRUE)])
  ggplot(ranks, aes(x=x, y=counts, fill= fill)) +
    geom_bar(stat="identity") +
    guides(fill=guide_legend(ncol=2)) +
    labs(list(x="Fields", y="Users", fill = "Fields"))
}
# calc ranks (warning: slow)
userFields<-calcTopicRanks(allgender$fields)
maleFields<-calcTopicRanks(male$fields)
femaleFields<-calcTopicRanks(female$fields)

```
**Topic rankings (total)**
```{r}
visualizeRanks(userFields, 20)

```
**Topic rankings (male)**
```{r}
visualizeRanks(femaleFields, 20)
```
**Topic rankings (female)**
```{r}
visualizeRanks(maleFields, 20)
```
**Topic diversities (# of topics)**
```{r}
# field diversities
cbind(c('#of topics (from behance site):', '#of topics (total in our data):', '#of topics (male in our data):', '#of topics (female in our data):'), c(length(systemFields), length(userFields), length(maleFields), length(femaleFields)))
```
**Comparison with system's popular fields**
: system's  popular fields seemed to be picked based on diversity, not actual popularities.
```{r}
cbind(names(head(userFields, n=12)),cfs$popular$name)
```

**Comparison between genders**
: web site & ux/ui do not appear in women's rankings, while they have fashion & editorial_design
```{r}
cbind(names(head(maleFields, n=12)),names(head(femaleFields, n=12)))
```
Add binary category variables (whether a user has a certain field or not)
```{r}
createCategoryVars<-function(data, field_names){
  for (i in 1:length(field_names)){
    print(paste("creating a variable name of ", paste("has_", field_names[i], sep="")))
    data[, paste("has_", field_names[i],sep="")]<-as.logical(sapply(data$fields, function(f){
      if (nchar(as.character(f))!=0){
        fields<-tolower(gsub(" ", "_", as.character(f)))
        grepl(field_names[i], fields)
      }else{
        FALSE
      }
    }))
  }
  data
}


allgender<-createCategoryVars(allgender, names(userFields[1:15]))
count(allgender$has_graphic_design) #sanity check
```
Add binary category variables (whether a user is from a certain country or not)
```{r}

# add binary country variables
createCountryVars<-function(data, country_names){
  for (i in 1:length(country_names)){
    print(paste("creating a variable name of ", paste("from_", country_names[i], sep="")))
    n<-tolower(gsub(" ", "_", as.character(country_names[i])))
    data[, paste("from_",n, sep="")]<-data$country==country_names[i]
  }
  data
}
allgender<-createCountryVars(allgender, as.character(factor(allGenderP[1:10, ]$country)))
count(allgender$from_united_states) #sanity check

```
Fix gender factor level (remove unknown fator)

```{r}
allgender$gender<-factor(allgender$gender)
```
**The distribution of followers by gender (log-transformed) **
: female has a lower median and but also more mass in the tail of their follower distribution
```{r}
dens <- with(allgender, tapply(log(followers+1), INDEX = gender, density))
df <- data.frame(
  x = unlist(lapply(dens, "[[", "x")),
  y = unlist(lapply(dens, "[[", "y")),
  cut = rep(names(dens), each = length(dens[[1]]$x))
)
plot_ly(df, x = ~x, y = ~y, color = ~cut)
with(allgender, tapply(followers, gender, describe))
```
**The distribution of project appreciations by gender (log-transformed)**
: same as above, women has relatively lower median of project appreciations.
```{r}
dens <- with(allgender, tapply(log(project_appreciations+1), INDEX = gender, density))
df <- data.frame(
  x = unlist(lapply(dens, "[[", "x")),
  y = unlist(lapply(dens, "[[", "y")),
  cut = rep(names(dens), each = length(dens[[1]]$x))
)
plot_ly(df, x = ~x, y = ~y, color = ~cut)
with(allgender, tapply(project_appreciations, gender, describe))

```
**Project appreciation & follower counts within topics**
: while graphic_design is the most popular, digital photography seems to have more followers and project appreciations
```{r}
allPhoto<-subset(allgender, allgender$has_digital_photography==1)
allGraphic<-subset(allgender, allgender$has_graphic_design==1)
describe(allGraphic$project_appreciations)
describe(allPhoto$project_appreciations)
describe(allGraphic$followers)
describe(allPhoto$followers)

```
**Project appreciation & follower counts within countries**
```{r}
allUS<-subset(allgender, allgender$from_united_states==1)
allBrazil<-subset(allgender, allgender$from_brazil==1)
allItaly<-subset(allgender, allgender$from_italy==1)

describe(allUS$project_appreciations)
describe(allBrazil$project_appreciations)
describe(allItaly$project_appreciations) 

```
```{r}
describe(allUS$followers)
describe(allBrazil$followers)
describe(allItaly$followers) 
```
### Prediction model #1 : negative binomial regression
 RQ. What structures connections?
 DV. # of followers
 IV. all other attributes
 *Potential alternative: zero-inflated model, but zero values seem legitimate in my case, not generated by other processes
 
```{r}
# remove unused attributes (e.g., user id, user names etc)
colnames(allgender)
regdata<-allgender[, c(3:4,6,8:12, 14:38)]
names(regdata)
```
**Fit a regression on all predictors**
```{r}
fitnb <- glm.nb(followers ~ ., data = regdata, maxit = 100, trace=TRUE)
summary(fitnb)
```
**Relative importance of predictors**
```{r}
beta_std <- lm.beta(fitnb)
rel_beta_std<-beta_std/sum(beta_std)
sort(rel_beta_std, decreasing = TRUE)

```
** Can I improve the model by removing less important variables**
```{r}

# fit<-update(fitnb, .~. -has_fashionTRUE-has_illustrationTRUE-from_egypt-has_photography
#                -has_graphic_design-frombrazil-from_india)
# anova(fitnb, fit)
```
```{r}
# summary(fit)
# AIC(fit) # need more experiments to find the final best model.
# AIC(fitnb)
# variable selection (error occurred)
# fitnb_back <- stepAIC(fitnb, trace=FALSE)
# summary(fitnb_back)
```
### Prediction model #2 : negative binomial regression
 Q. What structures connections?
 DV. # of project appreciations
 IV. all other attributes

**Fit a regression on all predictors **
```{r}

fitnb_pa <- glm.nb(project_appreciations ~ ., data = regdata, maxit = 100, trace=TRUE)
summary(fitnb_pa)
```
**Relative importance of predictors**
```{r}
beta_std <- lm.beta(fitnb_pa)
sort(beta_std, decreasing = TRUE)



```

**What if I remove non-significant metrics?**
```{r}
fit_pa<-update(fitnb_pa, .~. -from_united_states
            -from_brazil-from_india-from_egypt-from_united_kingdom-collection_followers)
anova(fitnb_pa, fit_pa)
```
```{r}
summary(fit_pa)
AIC(fit_pa) 
AIC(fitnb_pa)
```
```{r}
# variable selection
# : commented because it's too slow
# : results ::  only collection_followers is removed from the full model

# fitnb_pa_back <- stepAIC(fitnb_pa, trace = FALSE)
# summary(fitnb_pa_back)
# modvar <- names(coef(fitnb_pa_back))
# modvar
# fullvar <- names(coef(fitnb_pa))
# fullvar
# excluded <- !fullvar %in% modvar   ## compare strings
# fullvar[excluded]
```
Which topics are most popular in terms of the number of designs users create per each topic?

```{r}

# visualize the rankings (up to # rankings)
visualizeRanksProjects<-function(fields, upto){

}

allTopics<-calcTopicRanks(designs$fields)
length(allTopics)
fields<- allTopics / sqrt(sum(allTopics^2))
upto<-30
ranks<-data.frame(fields=names(fields[1:upto]), counts=fields[1:upto])
# reorder factors to match colors and bars
ranks$fill<-factor(ranks$fields, levels = ranks$fields[order(ranks$counts, decreasing=TRUE)])
ranks$x<-as.character(1:length(ranks$fields))
ranks$x<-factor(ranks$x, levels = ranks$x[order(ranks$counts, decreasing=TRUE)])
g<-ggplot(ranks, aes(x=x, y=counts, fill= fill)) +
  geom_bar(stat="identity") +
  guides(fill=guide_legend(ncol=3)) +
  labs(list(x="Fields", y="Normalized count", fill = "Fields"))

g
ggsave('topics.pdf', width=12, height=3.5)
```
How topics are related?
```{r}
# initialize topic vectors
topics<-names(allTopics)[1:20]
topicVecs<-vector('list', length(topics))
vecSize<-nrow(designs)
for (topicName in topics){
  print(topicName)
  idx<-which(topics==topicName)
  topicVecs[[idx]]<-vector(length = vecSize)
}

for (i in 1:vecSize){
  # print(i)
  f<-designs[i,]$fields
  if (nchar(as.character(f))!=0){
      splited<-strsplit(as.character(f), "|", fixed = TRUE)
      splited<-unlist(splited)
      for (j in 1:length(splited)){
        field<-tolower(gsub(" ", "_", splited[j]))
        # print(field)
        locVec<-topics==field
        if (any(locVec)){
          idx<-which(locVec)
          # print(idx)
          topicVecs[[idx]][i]<-TRUE  
        }
        
      }
  }
}


simVals<-hash()
for (i in 1:length(topics)){
  for (j in i:length(topics)){
    topicName1<-topics[i]
    topicName2<-topics[j]
    idx1<-which(topics==topicName1)
    idx2<-which(topics==topicName2)
    if (topicName1!=topicName2){
      key<-paste0(topicName1,' vs ',topicName2)
      print(key)
      
      dist(topicVecs[[idx1]],topicVecs[[idx2]], method = "Jaccard", pairwise = TRUE)
      
      excluded <-Reduce('&', rbind(topicVecs[idx1], topicVecs[idx2]))
      combined <-Reduce('|', rbind(topicVecs[idx1], topicVecs[idx2]))
      simVal<-length(excluded[excluded==TRUE])/length(combined[combined==TRUE])
      print(simVal)
      simVals[[key]]<-simVal
    }
  }
}
simVals<-sort(values(simVals), decreasing=TRUE)

```

